use bajzel_lib::lexer::{lex_tokens, Token};
use pretty_assertions::assert_eq;
use std::fs::read_to_string;

#[test]
fn example0() {
    let input = read_to_string("./examples/example0.fuzl").unwrap();
    let output = lex_tokens(input.as_str());
    let expected = vec![
        Token::Define,
        // Field 1
        Token::Ident("string_cmd"),
        Token::Type("string"),
        Token::As,
        Token::Ident("cmd"),
        Token::RightArrow,
        Token::Ident("LEN"),
        Token::LeftParen,
        Token::IntegerLiteral(4),
        Token::RightParen,
        // Field 2
        Token::StringLiteral(" "),
        // Field 3
        Token::Type("string"),
        Token::As,
        Token::Ident("sub_cmd"),
        Token::RightArrow,
        Token::Ident("LEN"),
        Token::LeftParen,
        Token::IntegerLiteral(1),
        Token::IntegerLiteral(10),
        Token::RightParen,
        // Field 4
        Token::StringLiteral(" "),
        // Field 5
        Token::Type("i32"),
        Token::As,
        Token::Ident("param"),
        Token::RightArrow,
        Token::Ident("RANGE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::IntegerLiteral(5),
        Token::RightParen,
        // Generate
        Token::Generate,
        Token::Ident("string_cmd"),
        Token::With,
        Token::Ident("OUT_MIN"),
        Token::Assign,
        Token::IntegerLiteral(5),
        Token::Ident("OUT_MAX"),
        Token::Assign,
        Token::IntegerLiteral(32),
        Token::Ident("TERM"),
        Token::Assign,
        Token::ReservedIdent("LF"),
        Token::Eof,
    ];

    assert_eq!(output, Ok(expected));
}

#[test]
fn example1() {
    let input = read_to_string("./examples/example1.fuzl").unwrap();
    let output = lex_tokens(input.as_str());
    let expected = vec![
        Token::Define,
        Token::Ident("repl_command"),
        Token::StringLiteral("REPL"),
        Token::As,
        Token::Ident("prefix"),
        Token::StringLiteral(":"),
        Token::As,
        Token::Ident("delim1"),
        Token::Type("u32"),
        Token::As,
        Token::Ident("payload_len"),
        Token::StringLiteral(","),
        Token::As,
        Token::Ident("delim2"),
        Token::Type("bytes"),
        Token::As,
        Token::Ident("payload"),
        Token::Type("ref"),
        Token::As,
        Token::Ident("mem_range"),
        Token::Where,
        Token::Ident("prefix"),
        Token::RightArrow,
        Token::Ident("NO_MUTATE"),
        Token::Comma,
        Token::Ident("delim1"),
        Token::RightArrow,
        Token::Ident("DELIM"),
        Token::Ident("NO_MUTATE"),
        Token::Comma,
        Token::Ident("payload_len"),
        Token::RightArrow,
        Token::Ident("RANGE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::IntegerLiteral(4096),
        Token::RightParen,
        Token::Comma,
        Token::Ident("delim2"),
        Token::RightArrow,
        Token::Ident("DELIM"),
        Token::Comma,
        Token::Ident("payload"),
        Token::RightArrow,
        Token::Ident("LEN"),
        Token::LeftParen,
        Token::Ident("payload_len"),
        Token::RightParen,
        Token::Comma,
        Token::Ident("mem_range"),
        Token::RightArrow,
        Token::Ident("DEF"),
        Token::LeftParen,
        Token::Ident("int_pair"),
        Token::RightParen,
        Token::Define,
        Token::Ident("int_pair"),
        Token::Type("i32"),
        Token::As,
        Token::Ident("x1"),
        Token::StringLiteral(","),
        Token::As,
        Token::Ident("delim"),
        Token::Type("i32"),
        Token::As,
        Token::Ident("x2"),
        Token::Where,
        Token::Ident("x1"),
        Token::RightArrow,
        Token::Ident("RANGE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::IntegerLiteral(15),
        Token::RightParen,
        Token::Comma,
        Token::Ident("x2"),
        Token::RightArrow,
        Token::Ident("RANGE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::IntegerLiteral(255),
        Token::RightParen,
        Token::Comma,
        Token::Ident("delim"),
        Token::RightArrow,
        Token::Ident("DELIM"),
        Token::Generate,
        Token::Ident("repl_command"),
        Token::With,
        Token::Ident("MIN"),
        Token::Assign,
        Token::IntegerLiteral(5),
        Token::Ident("MAX"),
        Token::Assign,
        Token::IntegerLiteral(4096),
        Token::Ident("TERM"),
        Token::Assign,
        Token::ReservedIdent("null"),
        Token::Eof,
    ];

    assert_eq!(output, Ok(expected));
}

#[test]
fn example2_bitmap() {
    let input = read_to_string("./examples/example2.fuzl").unwrap();
    let output = lex_tokens(input.as_str());
    let expected = vec![
        // Bitmap header
        Token::Define,
        Token::Ident("bmp_header"),
        Token::Bytes(vec![66, 77]),
        Token::As,
        Token::Ident("magic"),
        Token::Type("le_u16"),
        Token::As,
        Token::Ident("size"),
        Token::TypeArray("bytes", 4),
        Token::Type("le_u16"),
        Token::As,
        Token::Ident("offset"),
        Token::Where,
        Token::Ident("offset"),
        Token::RightArrow,
        Token::Ident("VALUE"),
        Token::LeftParen,
        Token::IntegerLiteral(14),
        Token::Add,
        Token::IntegerLiteral(40),
        Token::RightParen,
        // Info Header
        Token::Define,
        Token::Ident("info_header"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("header_size"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("width"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("height"),
        Token::Type("le_u16"),
        Token::As,
        Token::Ident("planes"),
        Token::Type("le_u16"),
        Token::As,
        Token::Ident("bit_count"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("compression"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("img_size"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("x_res"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("y_res"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("colors_used"),
        Token::Type("le_u32"),
        Token::As,
        Token::Ident("colors_imp"),
        Token::Where,
        Token::Ident("header_size"),
        Token::RightArrow,
        Token::Ident("VALUE"),
        Token::LeftParen,
        Token::IntegerLiteral(40),
        Token::RightParen,
        Token::Ident("bit_count"),
        Token::RightArrow,
        Token::Ident("VALUE"),
        Token::LeftParen,
        Token::IntegerLiteral(24),
        Token::RightParen,
        Token::Ident("compression"),
        Token::RightArrow,
        Token::Ident("VALUE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::RightParen,
        Token::Ident("img_size"),
        Token::RightArrow,
        Token::Ident("VALUE"),
        Token::LeftParen,
        Token::IntegerLiteral(0),
        Token::RightParen,
        // Bmp file
        Token::Define,
        Token::Ident("bmp_file"),
        Token::Type("ref"),
        Token::As,
        Token::Ident("bh"),
        Token::From,
        Token::Ident("bmp_header"),
        Token::Type("ref"),
        Token::As,
        Token::Ident("ih"),
        Token::From,
        Token::Ident("info_header"),
        Token::Type("bytes"),
        Token::As,
        Token::Ident("pixel_data"),
        Token::Where,
        Token::Ident("pixel_data"),
        Token::RightArrow,
        Token::Ident("LEN"),
        Token::LeftParen,
        Token::Reference,
        Token::Ident("ih"),
        Token::Colon,
        Token::Ident("width"),
        Token::Multiply,
        Token::Reference,
        Token::Ident("ih"),
        Token::Colon,
        Token::Ident("height"),
        Token::Multiply,
        Token::Reference,
        Token::Ident("ih"),
        Token::Colon,
        Token::Ident("bit_count"),
        Token::RightParen,
        Token::Eof,
    ];

    assert_eq!(output, Ok(expected));
}
